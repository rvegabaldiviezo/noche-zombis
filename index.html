<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>ü¶á Survival Horror 3D - Noche de los Muertos</title>
<style>
body {
  margin: 0;
  overflow: hidden;
  font-family: 'Arial', sans-serif;
  cursor: none;
  background: #000;
}

#hud {
  position: absolute;
  top: 10px;
  left: 10px;
  color: #ff4444;
  background: rgba(0,0,0,0.85);
  padding: 15px;
  border-radius: 10px;
  font-size: 16px;
  min-width: 220px;
  max-width: 220px;
  backdrop-filter: blur(5px);
  border: 2px solid #660000;
  box-shadow: 0 0 20px rgba(255,0,0,0.3);
}

#hud-right {
  position: absolute;
  top: 10px;
  right: 10px;
  color: #ff4444;
  background: rgba(0,0,0,0.85);
  padding: 15px;
  border-radius: 10px;
  font-size: 16px;
  text-align: right;
  backdrop-filter: blur(5px);
  border: 2px solid #660000;
  box-shadow: 0 0 20px rgba(255,0,0,0.3);
}

#bomb-indicator {
  position: absolute;
  top: 10px;
  right: 10px;
  color: #ffaa00;
  background: rgba(0,0,0,0.85);
  padding: 12px 15px;
  border-radius: 10px;
  font-size: 16px;
  border: 2px solid #664400;
  box-shadow: 0 0 20px rgba(255,170,0,0.3);
  margin-top: 110px;
}

#bomb-cooldown {
  width: 100px;
  height: 8px;
  background: #333;
  border-radius: 4px;
  margin-top: 5px;
  overflow: hidden;
}

#bomb-cooldown-bar {
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, #ff6600, #ffaa00);
  transition: width 0.1s linear;
}

#weapon-indicator {
  position: absolute;
  bottom: 60px;
  left: 10px;
  color: #44ff44;
  background: rgba(0,0,0,0.85);
  padding: 10px 15px;
  border-radius: 10px;
  font-size: 14px;
  border: 2px solid #226622;
  box-shadow: 0 0 20px rgba(68,255,68,0.3);
}

#instructions {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.85);
  color: #ff4444;
  padding: 12px 20px;
  border-radius: 10px;
  font-size: 14px;
  backdrop-filter: blur(5px);
  border: 2px solid #660000;
}

#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  pointer-events: none;
}

.crosshair-line {
  position: absolute;
  background: rgba(255,50,50,0.9);
  box-shadow: 0 0 5px rgba(255,0,0,0.5);
}

.crosshair-h {
  width: 20px;
  height: 2px;
  left: -10px;
  top: -1px;
}

.crosshair-v {
  width: 2px;
  height: 20px;
  left: -1px;
  top: -10px;
}

.crosshair-dot {
  width: 4px;
  height: 4px;
  background: #ff0000;
  border-radius: 50%;
  left: -2px;
  top: -2px;
  box-shadow: 0 0 8px rgba(255,0,0,0.8);
}

#damage-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0) 100%);
  opacity: 0;
  transition: opacity 0.3s;
}

#damage-overlay.active {
  background: radial-gradient(circle, transparent 30%, rgba(255,0,0,0.5) 100%);
  opacity: 1;
}

#level-complete {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.95);
  color: #44ff44;
  padding: 40px 60px;
  border-radius: 20px;
  text-align: center;
  display: none;
  z-index: 1000;
  border: 3px solid #226622;
  box-shadow: 0 0 30px rgba(68,255,68,0.3);
}

#level-complete h1 {
  margin: 0 0 20px 0;
  font-size: 48px;
  color: #44ff44;
  text-shadow: 0 0 10px #44ff44;
}

#level-complete p {
  font-size: 20px;
  margin: 10px 0;
  color: #88ff88;
}

#game-over {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.95);
  color: #ff4444;
  padding: 40px 60px;
  border-radius: 20px;
  text-align: center;
  display: none;
  z-index: 1000;
  border: 3px solid #660000;
  box-shadow: 0 0 30px rgba(255,0,0,0.5);
}

#game-over h1 {
  margin: 0 0 20px 0;
  font-size: 48px;
  color: #ff0000;
  text-shadow: 0 0 15px #ff0000;
}

#click-to-start {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(0,0,0,0.95);
  color: #ff4444;
  padding: 50px 70px;
  border-radius: 20px;
  text-align: center;
  z-index: 1000;
  cursor: pointer;
  border: 3px solid #660000;
  box-shadow: 0 0 40px rgba(255,0,0,0.5);
}

#click-to-start h1 {
  margin: 0 0 20px 0;
  font-size: 52px;
  text-shadow: 0 0 15px #ff0000;
}

#click-to-start p {
  color: #ff8888;
}

#menu-control {
  position: fixed;
  bottom: 10px;
  right: 10px;
  background: rgba(0,0,0,0.85);
  padding: 10px 15px;
  border-radius: 10px;
  border: 2px solid #660000;
  display: none;
  backdrop-filter: blur(5px);
  box-shadow: 0 0 20px rgba(255,0,0,0.3);
  z-index: 999;
}

#menu-control button {
  background: #660000;
  color: #ff4444;
  border: none;
  padding: 8px 15px;
  margin: 5px 0;
  border-radius: 5px;
  cursor: pointer;
  width: 100%;
  font-size: 14px;
  font-weight: bold;
  transition: all 0.2s;
}

#menu-control button:hover {
  background: #880000;
  box-shadow: 0 0 10px rgba(255,68,68,0.5);
  transform: scale(1.05);
}

#game-over button, #level-complete button {
  background: #660000;
  color: #ff4444;
  border: none;
  padding: 12px 30px;
  border-radius: 10px;
  cursor: pointer;
  font-size: 18px;
  font-weight: bold;
  margin-top: 20px;
  transition: all 0.2s;
}

#game-over button:hover, #level-complete button:hover {
  background: #880000;
  box-shadow: 0 0 15px rgba(255,68,68,0.6);
  transform: scale(1.05);
}
</style>
</head>
<body>

<div id="hud">
  ü©∏ Vida: <span id="vida">100</span>%<br>
  üíÄ Ola: <span id="nivel">1</span><br>
  ‚ò†Ô∏è Bajas: <span id="bajas">0</span>
</div>

<div id="hud-right">
  üßü Zombis: <span id="enemigos-restantes">0</span><br>
  üëπ Jefe: <span id="jefe-vida">100</span>%
</div>

<div id="bomb-indicator">
  üí£ Bomba: <span id="bomb-status">LISTA</span>
  <div id="bomb-cooldown">
    <div id="bomb-cooldown-bar"></div>
  </div>
</div>

<div id="weapon-indicator">
  üî´ Arma: <span id="arma-actual">PISTOLA</span><br>
  <span style="font-size: 12px; opacity: 0.7;">1-Pistola | 2-Granada | 3-Cuchillo | Q-Cambiar</span>
</div>

<div id="instructions">
  üéÆ WASD mover | üñ± Mouse apuntar | üî´ Click disparar<br>
  üí£ ESPACIO granada | üî™ 1-Pistola 2-Granada 3-Cuchillo | Q-Cambiar arma | ESC salir
</div>

<div id="crosshair">
  <div class="crosshair-line crosshair-h"></div>
  <div class="crosshair-line crosshair-v"></div>
  <div class="crosshair-line crosshair-dot"></div>
</div>

<div id="damage-overlay"></div>

<div id="level-complete">
  <h1>‚úÖ ¬°FELICITACIONES!</h1>
  <h2 style="font-size: 24px; margin: 10px 0; color: #ffcc00;">üèÜ PASASTE AL SIGUIENTE NIVEL üèÜ</h2>
  <p>Zombis eliminados: <span id="lc-bajas">0</span></p>
  <p>Vida restante: <span id="lc-vida">0</span>%</p>
  <p style="font-size: 20px; margin-top: 20px; color: #ff69b4;">
    <strong>üëë La Princesa Sofi te desea suerte en el siguiente nivel üëë</strong>
  </p>
  <p><em>Entra al portal para continuar...</em></p>
</div>

<div id="game-over">
  <h1>‚ò†Ô∏è HAS MUERTO</h1>
  <p>Ola alcanzada: <span id="go-nivel">0</span></p>
  <p>Bajas totales: <span id="go-bajas">0</span></p>
  <button id="btn-restart-gameover">üîÑ Reintentar</button>
</div>

<div id="click-to-start">
  <h1>ü¶á NOCHE DE LOS MUERTOS ü¶á</h1>
  <p style="font-size: 22px; margin: 20px 0;">¬°Sobrevive a las olas de zombis!</p>
  <p style="font-size: 18px; color: #ff69b4; margin: 15px 0;">
    <strong>üëë Un juego dedicado a la Princesa Sofi üëë</strong>
  </p>
  <p style="font-size: 16px; opacity: 0.8;">Haz click para comenzar la pesadilla</p>
</div>

<div id="menu-control">
  <button id="btn-reiniciar-nivel">üîÑ Reiniciar Nivel</button>
  <button id="btn-reiniciar-juego">üè† Reiniciar Juego</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
// ============ VARIABLES GLOBALES ============
let nivel = 1;
let vidaJugador = 100;
let enemigos = [];
let jefe = null;
let bajasTotal = 0;
let gameStarted = false;
let gamePaused = false;
let canShoot = true;
let shootCooldown = 200;

// Sistema de bombas
let bombaDisponible = true;
let bombaCooldown = 6000;
let bombasActivas = [];

// Sistema de armas
let armaActual = 'pistola'; // 'pistola', 'granada', 'cuchillo'
const armas = {
  pistola: { danio: 20, cooldown: 200, alcance: 1000 },
  granada: { danio: 80, cooldown: 6000, alcance: 20 },
  cuchillo: { danio: 50, cooldown: 500, alcance: 2 }
};

// Portal de nivel
let portal = null;

// Sistema de items de vida
let itemsVida = [];

// Controles
const keys = {};
let mouseX = 0;
let mouseY = 0;
let rotationY = 0;
let rotationX = 0;

// Sacudida de c√°mara
let cameraShake = 0;

// ============ CONFIGURACI√ìN THREE.JS ============
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0f0f1e, 10, 60);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// ============ ILUMINACI√ìN TERROR√çFICA ============
const ambientLight = new THREE.AmbientLight(0x4a4a6a, 0.3);
scene.add(ambientLight);

const sun = new THREE.DirectionalLight(0x6a6a8a, 0.4);
sun.position.set(50, 50, 50);
sun.castShadow = true;
sun.shadow.camera.left = -50;
sun.shadow.camera.right = 50;
sun.shadow.camera.top = 50;
sun.shadow.camera.bottom = -50;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
scene.add(sun);

// Luces ominosas
const redLight = new THREE.PointLight(0xff0000, 0.5, 30);
redLight.position.set(-20, 5, -20);
scene.add(redLight);

const greenLight = new THREE.PointLight(0x00ff00, 0.3, 25);
greenLight.position.set(20, 5, -30);
scene.add(greenLight);

// ============ TEMAS DE NIVELES TERROR√çFICOS ============
const levelThemes = {
  1: { name: 'ü™¶ Cementerio Maldito', sky: 0x1a1a2e, ground: 0x2d3436, fog: 0x0f0f1e },
  2: { name: 'üè• Hospital Abandonado', sky: 0x2c2c3e, ground: 0x3d3d4d, fog: 0x1a1a2a },
  3: { name: 'üå≤ Bosque Embrujado', sky: 0x0d1b0d, ground: 0x1a2e1a, fog: 0x0a150a },
  4: { name: 'üß™ Laboratorio T√≥xico', sky: 0x1a2e1a, ground: 0x2d4a2d, fog: 0x0f1e0f },
  5: { name: 'üî• Infierno Sangriento', sky: 0x4a0000, ground: 0x2e0000, fog: 0x3a0000 }
};

function aplicarTema(nivel) {
  const tema = levelThemes[nivel] || levelThemes[5];
  scene.background = new THREE.Color(tema.sky);
  scene.fog = new THREE.Fog(tema.fog, 10, 60);
  ground.material.color.setHex(tema.ground);
}

// ============ SUELO ============
const groundGeometry = new THREE.PlaneGeometry(200, 200, 30, 30);
const groundMaterial = new THREE.MeshStandardMaterial({
  color: 0x2d3436,
  roughness: 0.9,
  metalness: 0.1
});
const ground = new THREE.Mesh(groundGeometry, groundMaterial);
ground.rotation.x = -Math.PI / 2;
ground.receiveShadow = true;

// Agregar irregularidades al suelo
for(let i = 0; i < groundGeometry.attributes.position.count; i++) {
  const z = groundGeometry.attributes.position.getZ(i);
  groundGeometry.attributes.position.setZ(i, z + Math.random() * 0.5 - 0.25);
}
groundGeometry.attributes.position.needsUpdate = true;
groundGeometry.computeVertexNormals();

scene.add(ground);

// Obst√°culos terror√≠ficos (l√°pidas, rocas)
function crearObstaculos() {
  for(let i = 0; i < 20; i++) {
    const isGrave = Math.random() > 0.5;

    let obstacle;
    if(isGrave) {
      // L√°pida
      obstacle = new THREE.Mesh(
        new THREE.BoxGeometry(0.8, 1.5, 0.2),
        new THREE.MeshStandardMaterial({ color: 0x4a4a5a, roughness: 0.9 })
      );
      obstacle.position.y = 0.75;
    } else {
      // Roca
      obstacle = new THREE.Mesh(
        new THREE.DodecahedronGeometry(0.5 + Math.random() * 1, 0),
        new THREE.MeshStandardMaterial({ color: 0x3a3a4a, roughness: 0.95 })
      );
      obstacle.position.y = obstacle.geometry.parameters.radius / 2;
    }

    obstacle.position.set(
      Math.random() * 80 - 40,
      obstacle.position.y,
      Math.random() * 80 - 40
    );
    obstacle.castShadow = true;
    obstacle.receiveShadow = true;
    scene.add(obstacle);
  }
}
crearObstaculos();

// ============ JUGADOR ============
const player = new THREE.Group();

const body = new THREE.Mesh(
  new THREE.CapsuleGeometry(0.5, 1.2, 8, 16),
  new THREE.MeshStandardMaterial({ color: 0x2a4a6a, roughness: 0.7 })
);
body.castShadow = true;
player.add(body);

const head = new THREE.Mesh(
  new THREE.SphereGeometry(0.35, 16, 16),
  new THREE.MeshStandardMaterial({ color: 0x2a4a6a })
);
head.position.set(0, 0.9, 0);
head.castShadow = true;
player.add(head);

const eyeLeft = new THREE.Mesh(
  new THREE.SphereGeometry(0.08, 8, 8),
  new THREE.MeshStandardMaterial({ color: 0xffffff })
);
eyeLeft.position.set(-0.12, 1, 0.3);
player.add(eyeLeft);

const eyeRight = eyeLeft.clone();
eyeRight.position.set(0.12, 1, 0.3);
player.add(eyeRight);

const pupilLeft = new THREE.Mesh(
  new THREE.SphereGeometry(0.04, 8, 8),
  new THREE.MeshStandardMaterial({ color: 0x000000 })
);
pupilLeft.position.set(-0.12, 1, 0.35);
player.add(pupilLeft);

const pupilRight = pupilLeft.clone();
pupilRight.position.set(0.12, 1, 0.35);
player.add(pupilRight);

const earLeft = new THREE.Mesh(
  new THREE.ConeGeometry(0.15, 0.4, 8),
  new THREE.MeshStandardMaterial({ color: 0x1a3a5a })
);
earLeft.position.set(-0.3, 1.2, 0);
earLeft.rotation.z = -Math.PI / 6;
player.add(earLeft);

const earRight = earLeft.clone();
earRight.position.set(0.3, 1.2, 0);
earRight.rotation.z = Math.PI / 6;
player.add(earRight);

// El arma se agrega din√°micamente con cambiarArma()

player.position.set(0, 0, 0);
scene.add(player);

camera.position.set(0, 1.6, 0);
player.add(camera);

// ============ CREAR ZOMBI TERROR√çFICO ============
function crearZombi(scale = 1, esJefe = false) {
  const zombie = new THREE.Group();

  // Color putrefacto
  const colorCuerpo = esJefe ? 0x8a0a0a : 0x5a7a5a;

  // Cuerpo deforme
  const cuerpo = new THREE.Mesh(
    new THREE.SphereGeometry(0.6 * scale, 12, 12),
    new THREE.MeshStandardMaterial({
      color: colorCuerpo,
      roughness: 0.95,
      metalness: 0
    })
  );
  cuerpo.position.y = 0.6 * scale;
  cuerpo.castShadow = true;
  cuerpo.scale.y = 0.9; // Deforme
  zombie.add(cuerpo);

  // Cabeza putrefacta
  const cabeza = new THREE.Mesh(
    new THREE.SphereGeometry(0.4 * scale, 12, 12),
    new THREE.MeshStandardMaterial({ color: colorCuerpo, roughness: 0.95 })
  );
  cabeza.position.set(0, 1.2 * scale, 0.4 * scale);
  cabeza.castShadow = true;
  cabeza.scale.set(1, 0.8, 1.1); // Deforme
  zombie.add(cabeza);

  // Ojos brillantes TERROR√çFICOS
  const ojoIzq = new THREE.Mesh(
    new THREE.SphereGeometry(0.12 * scale, 8, 8),
    new THREE.MeshStandardMaterial({
      color: 0xff0000,
      emissive: 0xff0000,
      emissiveIntensity: 0.9
    })
  );
  ojoIzq.position.set(-0.15 * scale, 1.25 * scale, 0.75 * scale);
  zombie.add(ojoIzq);

  const ojoDer = ojoIzq.clone();
  ojoDer.position.set(0.15 * scale, 1.25 * scale, 0.75 * scale);
  zombie.add(ojoDer);

  // Boca terror√≠fica
  const boca = new THREE.Mesh(
    new THREE.BoxGeometry(0.2 * scale, 0.05 * scale, 0.05 * scale),
    new THREE.MeshStandardMaterial({ color: 0x000000 })
  );
  boca.position.set(0, 1.1 * scale, 0.8 * scale);
  zombie.add(boca);

  // 4 Patas deformes
  for(let i = 0; i < 4; i++) {
    const pata = new THREE.Mesh(
      new THREE.CylinderGeometry(0.08 * scale, 0.06 * scale, 0.5 * scale, 6),
      new THREE.MeshStandardMaterial({ color: colorCuerpo, roughness: 0.95 })
    );
    const x = (i % 2 === 0 ? -1 : 1) * 0.3 * scale;
    const z = (i < 2 ? 1 : -1) * 0.2 * scale;
    pata.position.set(x, 0.25 * scale, z);
    pata.castShadow = true;
    zombie.add(pata);
  }

  // Cola putrefacta
  const cola = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05 * scale, 0.1 * scale, 0.6 * scale),
    new THREE.MeshStandardMaterial({ color: colorCuerpo })
  );
  cola.rotation.x = Math.PI / 4;
  cola.position.set(0, 0.5 * scale, -0.7 * scale);
  zombie.add(cola);

  // Jefe - Corona de HUESOS
  if(esJefe) {
    const coronaHueso = new THREE.Mesh(
      new THREE.ConeGeometry(0.3 * scale, 0.5 * scale, 6),
      new THREE.MeshStandardMaterial({
        color: 0xccccaa,
        roughness: 0.9
      })
    );
    coronaHueso.position.set(0, 1.7 * scale, 0.4 * scale);
    zombie.add(coronaHueso);

    // P√∫as largas y terror√≠ficas
    for(let i = 0; i < 8; i++) {
      const pua = new THREE.Mesh(
        new THREE.ConeGeometry(0.12 * scale, 0.5 * scale, 4),
        new THREE.MeshStandardMaterial({ color: 0x3a3a3a })
      );
      const angle = (i / 8) * Math.PI * 2;
      pua.position.set(
        Math.cos(angle) * 0.7 * scale,
        0.6 * scale,
        Math.sin(angle) * 0.7 * scale
      );
      zombie.add(pua);
    }
  }

  zombie.vida = esJefe ? 150 + nivel * 50 : 40 * scale;
  zombie.vidaMax = zombie.vida;
  zombie.velocidad = 0.02 + nivel * 0.005;
  zombie.danio = esJefe ? 15 : 10;

  // MARCAR como enemigo para detecci√≥n
  zombie.userData.esEnemigo = true;

  // Inicializar texto de vida
  actualizarBarraVida(zombie);

  return zombie;
}

// ============ CREAR BRAZO CON ARMA VISIBLE ============
function crearBrazoConArma(tipoArma) {
  const brazo = new THREE.Group();

  // Brazo
  const antebrazo = new THREE.Mesh(
    new THREE.CylinderGeometry(0.08, 0.06, 0.8),
    new THREE.MeshStandardMaterial({ color: 0xd4a574 })
  );
  antebrazo.rotation.z = Math.PI / 6;
  antebrazo.position.set(0.4, -0.3, 0.5);
  brazo.add(antebrazo);

  // Mano
  const mano = new THREE.Mesh(
    new THREE.SphereGeometry(0.1),
    new THREE.MeshStandardMaterial({ color: 0xd4a574 })
  );
  mano.position.set(0.4, -0.6, 0.7);
  brazo.add(mano);

  // Arma seg√∫n tipo
  let armaModel;
  if(tipoArma === 'pistola') {
    armaModel = new THREE.Group();

    const canon = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04, 0.04, 0.6),
      new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9 })
    );
    canon.rotation.z = Math.PI / 2;
    armaModel.add(canon);

    const empunadura = new THREE.Mesh(
      new THREE.BoxGeometry(0.08, 0.25, 0.12),
      new THREE.MeshStandardMaterial({ color: 0x3a2a1a })
    );
    empunadura.position.y = -0.15;
    armaModel.add(empunadura);

    armaModel.position.set(0.4, -0.5, 0.8);
    armaModel.rotation.set(0, 0, -Math.PI / 12);

  } else if(tipoArma === 'granada') {
    armaModel = new THREE.Mesh(
      new THREE.SphereGeometry(0.12),
      new THREE.MeshStandardMaterial({
        color: 0x2a4a2a,
        roughness: 0.8
      })
    );
    armaModel.position.set(0.35, -0.55, 0.75);

  } else if(tipoArma === 'cuchillo') {
    armaModel = new THREE.Group();

    const hoja = new THREE.Mesh(
      new THREE.BoxGeometry(0.05, 0.4, 0.02),
      new THREE.MeshStandardMaterial({
        color: 0xcccccc,
        metalness: 1,
        roughness: 0.2
      })
    );
    hoja.position.y = 0.2;
    armaModel.add(hoja);

    const mango = new THREE.Mesh(
      new THREE.CylinderGeometry(0.04, 0.04, 0.2),
      new THREE.MeshStandardMaterial({ color: 0x3a2a1a })
    );
    mango.position.y = -0.1;
    armaModel.add(mango);

    armaModel.position.set(0.4, -0.4, 0.8);
    armaModel.rotation.set(0, Math.PI / 4, -Math.PI / 6);
  }

  brazo.add(armaModel);
  return brazo;
}

// ============ CAMBIAR ARMA ============
function cambiarArma(nuevaArma) {
  if(!gameStarted) return;

  armaActual = nuevaArma;

  // Remover arma anterior
  const armaVieja = player.children.find(c => c.userData.esArma);
  if(armaVieja) player.remove(armaVieja);

  // Agregar nueva arma
  const nuevaArmaModel = crearBrazoConArma(nuevaArma);
  nuevaArmaModel.userData.esArma = true;
  player.add(nuevaArmaModel);

  // Actualizar UI
  document.getElementById('arma-actual').textContent = nuevaArma.toUpperCase();
}

// ============ CREAR ENEMIGOS ============
function crearEnemigos() {
  enemigos.forEach(e => scene.remove(e));
  if(jefe) scene.remove(jefe);
  enemigos = [];

  const numEnemigos = Math.min(nivel + 2, 12);
  for(let i = 0; i < numEnemigos; i++) {
    const e = crearZombi(1, false);
    e.position.set(
      Math.random() * 20 - 10,
      0,
      Math.random() * -30 - 10
    );
    scene.add(e);
    enemigos.push(e);
  }

  // Jefe
  jefe = crearZombi(1.8 + nivel * 0.15, true);
  jefe.position.set(0, 0, -40 - nivel * 5);
  scene.add(jefe);

  // Crear items de vida
  crearItemsVida();

  actualizarHUD();
}

// ============ EFECTOS DE SONIDO TERROR√çFICOS ============
const audioContext = new (window.AudioContext || window.webkitAudioContext)();

function playSound(type) {
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();

  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);

  switch(type) {
    case 'shoot':
      oscillator.type = 'square';
      oscillator.frequency.value = 600;
      gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.08);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.08);
      break;
    case 'hit':
      oscillator.type = 'square';
      oscillator.frequency.value = 250;
      gainNode.gain.setValueAtTime(0.35, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.2);
      break;
    case 'knife':
      oscillator.type = 'sawtooth';
      oscillator.frequency.value = 400;
      gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.15);
      break;
    case 'death':
      oscillator.type = 'sawtooth';
      oscillator.frequency.value = 80;
      gainNode.gain.setValueAtTime(0.35, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.7);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.7);
      break;
    case 'damage':
      oscillator.type = 'triangle';
      oscillator.frequency.value = 120;
      gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.25);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.25);
      break;
    case 'levelup':
      oscillator.frequency.value = 523;
      gainNode.gain.setValueAtTime(0.18, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 1);
      break;
    case 'explosion':
      oscillator.type = 'sawtooth';
      oscillator.frequency.value = 60;
      gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.8);
      oscillator.start(audioContext.currentTime);
      oscillator.stop(audioContext.currentTime + 0.8);
      break;
  }
}

// ============ SISTEMA DE PART√çCULAS MEJORADO ============
function crearExplosion(position, color = 0xff0000, count = 20) {
  for(let i = 0; i < count; i++) {
    const particle = new THREE.Mesh(
      new THREE.SphereGeometry(0.1, 4, 4),
      new THREE.MeshBasicMaterial({ color })
    );
    particle.position.copy(position);

    const velocity = new THREE.Vector3(
      Math.random() - 0.5,
      Math.random() - 0.5,
      Math.random() - 0.5
    ).multiplyScalar(0.3);

    particle.userData.velocity = velocity;
    particle.userData.life = 1;
    scene.add(particle);

    const animate = () => {
      particle.position.add(particle.userData.velocity);
      particle.userData.velocity.y -= 0.01;
      particle.userData.life -= 0.02;
      particle.scale.multiplyScalar(0.95);

      if(particle.userData.life > 0) {
        requestAnimationFrame(animate);
      } else {
        scene.remove(particle);
      }
    };
    animate();
  }
}

// ============ N√öMEROS DE DA√ëO FLOTANTES ============
function mostrarDanio(posicion, cantidad) {
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');
  ctx.font = 'Bold 48px Arial';
  ctx.fillStyle = '#ff0000';
  ctx.fillText('-' + Math.round(cantidad), 10, 50);

  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
  const sprite = new THREE.Sprite(material);

  sprite.position.copy(posicion);
  sprite.position.y += 1;
  sprite.scale.set(1, 0.5, 1);
  scene.add(sprite);

  // Animar hacia arriba y fade
  let opacity = 1;
  const animateText = () => {
    sprite.position.y += 0.02;
    opacity -= 0.02;
    sprite.material.opacity = opacity;

    if(opacity > 0) {
      requestAnimationFrame(animateText);
    } else {
      scene.remove(sprite);
    }
  };
  animateText();
}

// ============ SISTEMA DE BOMBAS ============
function lanzarBomba() {
  if(!bombaDisponible || !gameStarted || gamePaused) return;

  bombaDisponible = false;

  // UI
  document.getElementById('bomb-status').textContent = 'RECARGANDO';
  document.getElementById('bomb-cooldown-bar').style.width = '0%';

  // Crear bomba
  const bomba = new THREE.Group();

  const bombaEsfera = new THREE.Mesh(
    new THREE.SphereGeometry(0.3, 16, 16),
    new THREE.MeshStandardMaterial({
      color: 0x2a2a2a,
      metalness: 0.7,
      roughness: 0.3
    })
  );
  bomba.add(bombaEsfera);

  // Mecha
  const mecha = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.05, 0.2),
    new THREE.MeshStandardMaterial({ color: 0x8a4a1a })
  );
  mecha.position.y = 0.4;
  bomba.add(mecha);

  // Chispa
  const chispa = new THREE.PointLight(0xff6600, 1, 3);
  chispa.position.y = 0.5;
  bomba.add(chispa);

  bomba.position.copy(player.position);
  bomba.position.y += 1.5;

  // Calcular velocidad de lanzamiento
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(camera.quaternion);

  const velocity = direction.multiplyScalar(0.5);
  velocity.y = 0.3; // Arco hacia arriba

  bomba.userData.velocity = velocity;
  bomba.userData.tiempoVida = 3; // 3 segundos antes de explotar

  scene.add(bomba);
  bombasActivas.push(bomba);

  // Cooldown
  let tiempoRecarga = 0;
  const intervalo = setInterval(() => {
    tiempoRecarga += 100;
    const progreso = (tiempoRecarga / bombaCooldown) * 100;
    document.getElementById('bomb-cooldown-bar').style.width = progreso + '%';

    if(tiempoRecarga >= bombaCooldown) {
      bombaDisponible = true;
      document.getElementById('bomb-status').textContent = 'LISTA';
      document.getElementById('bomb-cooldown-bar').style.width = '100%';
      clearInterval(intervalo);
    }
  }, 100);
}

function lanzarGranada() {
  if(!canShoot || !gameStarted || gamePaused) return;

  const armaConfig = armas.granada;

  // Cooldown
  canShoot = false;
  setTimeout(() => canShoot = true, armaConfig.cooldown);

  // Crear proyectil de granada
  const proyectil = new THREE.Mesh(
    new THREE.SphereGeometry(0.15),
    new THREE.MeshStandardMaterial({
      color: 0x2a4a2a,
      metalness: 0.5,
      roughness: 0.4
    })
  );

  proyectil.position.copy(camera.getWorldPosition(new THREE.Vector3()));

  // Direcci√≥n hacia donde apunta el mouse (c√°mara)
  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(camera.quaternion);

  proyectil.userData.velocity = direction.multiplyScalar(0.8);
  proyectil.userData.tiempoVida = 2; // Explota despu√©s de 2 segundos
  proyectil.userData.esGranada = true;

  scene.add(proyectil);
  bombasActivas.push(proyectil);

  playSound('shoot');
}

function actualizarBombas(deltaTime) {
  bombasActivas.forEach((bomba, index) => {
    if(!bomba.parent) {
      bombasActivas.splice(index, 1);
      return;
    }

    // F√≠sica
    bomba.userData.velocity.y -= 0.015 * deltaTime; // Gravedad
    bomba.position.add(bomba.userData.velocity.clone().multiplyScalar(deltaTime));

    // Rotaci√≥n
    bomba.rotation.x += 0.1 * deltaTime;
    bomba.rotation.y += 0.15 * deltaTime;

    // Tiempo de vida
    bomba.userData.tiempoVida -= 0.016 * deltaTime;

    // Colisi√≥n con suelo o tiempo acabado
    if(bomba.position.y <= 0.3 || bomba.userData.tiempoVida <= 0) {
      // EXPLOSI√ìN
      playSound('explosion');

      // Part√≠culas masivas
      crearExplosion(bomba.position, 0xff6600, 60);
      crearExplosion(bomba.position, 0xffaa00, 40);

      // Luz de explosi√≥n
      const explosionLight = new THREE.PointLight(0xff6600, 5, 20);
      explosionLight.position.copy(bomba.position);
      scene.add(explosionLight);
      setTimeout(() => scene.remove(explosionLight), 200);

      // Sacudida de c√°mara
      cameraShake = 0.3;

      // Da√±o a enemigos en radio
      const radioExplosion = 5;
      [...enemigos, jefe].forEach(e => {
        if(!e || !e.parent) return;

        const dist = e.position.distanceTo(bomba.position);
        if(dist < radioExplosion) {
          const danio = 80 * (1 - dist / radioExplosion); // M√°s da√±o cerca
          e.vida -= danio;

          // ACTUALIZAR BARRA INMEDIATAMENTE
          actualizarBarraVida(e);

          // MOSTRAR DA√ëO FLOTANTE
          mostrarDanio(e.position, danio);

          // Efecto visual
          crearExplosion(e.position, 0xff0000, 15);

          if(e.vida <= 0) {
            playSound('death');
            crearExplosion(e.position, 0xff0000, 30);
            scene.remove(e);

            if(e === jefe) {
              bajasTotal++;
              jefe = null;
              nivelCompletado();
            } else {
              enemigos = enemigos.filter(en => en !== e);
              bajasTotal++;
            }
          }
        }
      });

      scene.remove(bomba);
      bombasActivas.splice(index, 1);

      // ACTUALIZAR HUD DESPU√âS DE LA EXPLOSI√ìN
      actualizarHUD();
    }
  });
}

// ============ ACTUALIZAR HUD ============
function actualizarHUD() {
  document.getElementById('vida').textContent = Math.max(0, Math.round(vidaJugador));
  document.getElementById('nivel').textContent = nivel;
  document.getElementById('bajas').textContent = bajasTotal;
  document.getElementById('enemigos-restantes').textContent = enemigos.length;
  document.getElementById('jefe-vida').textContent = jefe ? Math.max(0, Math.round((jefe.vida / jefe.vidaMax) * 100)) : 0;
}

// ============ ACTUALIZAR TEXTO DE VIDA INDIVIDUAL ============
function actualizarBarraVida(enemigo) {
  if(!enemigo) return;

  const porcentaje = Math.max(0, Math.round((enemigo.vida / enemigo.vidaMax) * 100));

  // Eliminar texto anterior si existe
  const textoAnterior = enemigo.children.find(c => c.userData.esTextoVida);
  if(textoAnterior) enemigo.remove(textoAnterior);

  // Determinar color seg√∫n porcentaje
  const color = porcentaje < 50 ? '#ff0000' : '#00ff00';  // Rojo si <50%, Verde si >=50%

  // Crear canvas con texto
  const canvas = document.createElement('canvas');
  canvas.width = 128;
  canvas.height = 64;
  const ctx = canvas.getContext('2d');

  ctx.font = 'Bold 40px Arial';
  ctx.fillStyle = color;
  ctx.textAlign = 'center';
  ctx.fillText(porcentaje + '%', 64, 45);

  // Crear sprite
  const texture = new THREE.CanvasTexture(canvas);
  const material = new THREE.SpriteMaterial({
    map: texture,
    transparent: true,
    depthTest: false  // Siempre visible sobre el enemigo
  });
  const sprite = new THREE.Sprite(material);

  // Posicionar sobre el enemigo
  sprite.position.set(0, 2, 0);
  sprite.scale.set(1, 0.5, 1);
  sprite.userData.esTextoVida = true;
  sprite.raycast = () => {};  // No interferir con disparos
  sprite.layers.set(1);  // Mover a layer 1 (raycaster usa layer 0)

  enemigo.add(sprite);
}

// ============ PORTAL DE SIGUIENTE NIVEL ============
function crearPortal() {
  portal = new THREE.Group();

  // Plataforma verde fluorescente
  const plataforma = new THREE.Mesh(
    new THREE.CylinderGeometry(2, 2, 0.2, 32),
    new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      emissive: 0x00ff00,
      emissiveIntensity: 0.8,
      transparent: true,
      opacity: 0.7
    })
  );
  plataforma.position.y = 0.1;
  portal.add(plataforma);

  // Part√≠culas verdes flotantes
  for(let i = 0; i < 20; i++) {
    const particula = new THREE.Mesh(
      new THREE.SphereGeometry(0.1),
      new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        transparent: true,
        opacity: 0.6
      })
    );
    particula.position.set(
      Math.random() * 3 - 1.5,
      Math.random() * 3,
      Math.random() * 3 - 1.5
    );
    particula.userData.offsetY = Math.random() * Math.PI * 2;
    portal.add(particula);
  }

  // Luz verde brillante
  const luz = new THREE.PointLight(0x00ff00, 2, 10);
  luz.position.y = 2;
  portal.add(luz);

  // Posici√≥n del portal (adelante del jugador)
  portal.position.set(0, 0, -15);
  scene.add(portal);
}

// ============ SISTEMA DE ITEMS DE VIDA ============
function crearItemVida() {
  const item = new THREE.Group();

  // Coraz√≥n (geometr√≠a simple - esfera)
  const corazon = new THREE.Mesh(
    new THREE.SphereGeometry(0.3, 16, 16),
    new THREE.MeshStandardMaterial({
      color: 0xff0066,
      emissive: 0xff0066,
      emissiveIntensity: 0.6,
      metalness: 0.4,
      roughness: 0.3
    })
  );
  item.add(corazon);

  // Cruz m√©dica horizontal
  const cruzH = new THREE.Mesh(
    new THREE.BoxGeometry(0.5, 0.1, 0.05),
    new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffffff,
      emissiveIntensity: 0.3
    })
  );
  cruzH.position.z = 0.35;
  item.add(cruzH);

  // Cruz m√©dica vertical
  const cruzV = new THREE.Mesh(
    new THREE.BoxGeometry(0.1, 0.5, 0.05),
    new THREE.MeshStandardMaterial({
      color: 0xffffff,
      emissive: 0xffffff,
      emissiveIntensity: 0.3
    })
  );
  cruzV.position.z = 0.35;
  item.add(cruzV);

  // Luz brillante rosa
  const luz = new THREE.PointLight(0xff0066, 1.5, 6);
  luz.position.y = 0.5;
  item.add(luz);

  item.userData.esItemVida = true;
  item.userData.curacion = 25; // +25% de vida

  return item;
}

function crearItemsVida() {
  // Limpiar items anteriores
  itemsVida.forEach(i => scene.remove(i));
  itemsVida.length = 0;

  // Crear 3-5 items por nivel
  const numItems = 3 + Math.floor(Math.random() * 3);

  for(let i = 0; i < numItems; i++) {
    const item = crearItemVida();

    // Posici√≥n aleatoria en el mapa (evitando spawn muy cerca del jugador)
    item.position.set(
      Math.random() * 60 - 30,  // x: -30 a +30
      0.5,                       // y: flotando
      Math.random() * 50 - 40   // z: -40 a +10 (m√°s lejos del spawn)
    );

    scene.add(item);
    itemsVida.push(item);
  }
}

// ============ CONTROLES ============
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;

  // Cambio de arma
  if(e.key === '1') cambiarArma('pistola');
  if(e.key === '2') cambiarArma('granada');
  if(e.key === '3') cambiarArma('cuchillo');

  // Rueda de armas con Q
  if(e.key === 'q' || e.key === 'Q') {
    const armasArray = ['pistola', 'granada', 'cuchillo'];
    const indexActual = armasArray.indexOf(armaActual);
    const siguienteIndex = (indexActual + 1) % 3;
    cambiarArma(armasArray[siguienteIndex]);
  }

  // Bomba con ESPACIO (solo si arma es granada)
  if(e.key === ' ' && armaActual === 'granada') {
    e.preventDefault();
    lanzarBomba();
  }

  if(e.key === 'Escape' && gameStarted) {
    document.exitPointerLock();
  }
});

window.addEventListener('keyup', e => {
  keys[e.key.toLowerCase()] = false;
});

// Pointer Lock
document.getElementById('click-to-start').addEventListener('click', () => {
  document.getElementById('click-to-start').style.display = 'none';
  document.getElementById('menu-control').style.display = 'block';
  renderer.domElement.requestPointerLock();
  gameStarted = true;

  // Inicializar arma pistola
  cambiarArma('pistola');

  crearEnemigos();
});

// Event listeners del men√∫ de control
document.getElementById('btn-reiniciar-nivel').addEventListener('click', () => {
  // Limpiar enemigos actuales
  enemigos.forEach(e => scene.remove(e));
  if(jefe) scene.remove(jefe);
  if(portal) scene.remove(portal);

  // Limpiar items de vida
  itemsVida.forEach(i => scene.remove(i));

  // Resetear jugador
  player.position.set(0, 0, 0);
  vidaJugador = 100;

  // Recrear enemigos del nivel actual
  crearEnemigos();
  actualizarHUD();

  // Volver a pointer lock
  renderer.domElement.requestPointerLock();
});

document.getElementById('btn-reiniciar-juego').addEventListener('click', () => {
  location.reload();
});

document.getElementById('btn-restart-gameover').addEventListener('click', () => {
  location.reload();
});

document.addEventListener('pointerlockchange', () => {
  gamePaused = document.pointerLockElement !== renderer.domElement;
});

document.addEventListener('mousemove', (e) => {
  if(!gamePaused && gameStarted) {
    mouseX = e.movementX || 0;
    mouseY = e.movementY || 0;

    rotationY -= mouseX * 0.002;
    rotationX -= mouseY * 0.002;

    rotationX = Math.max(-Math.PI / 2.5, Math.min(Math.PI / 2.5, rotationX));
  }
});

// Disparo
document.addEventListener('click', () => {
  if(!gameStarted || gamePaused || !canShoot || vidaJugador <= 0) return;

  // Granada se lanza como proyectil
  if(armaActual === 'granada') {
    lanzarGranada();
    return;
  }

  const armaConfig = armas[armaActual];

  // Cooldown seg√∫n arma
  canShoot = false;
  setTimeout(() => canShoot = true, armaConfig.cooldown);

  // Sonido seg√∫n arma
  if(armaActual === 'pistola') {
    playSound('shoot');
  } else if(armaActual === 'cuchillo') {
    playSound('knife');
  }

  // Fogonazo (solo pistola)
  if(armaActual === 'pistola') {
    const muzzleFlash = new THREE.PointLight(0xffff00, 2, 5);
    muzzleFlash.position.copy(camera.getWorldPosition(new THREE.Vector3()));
    scene.add(muzzleFlash);
    setTimeout(() => scene.remove(muzzleFlash), 50);
  }

  // Raycaster con alcance seg√∫n arma
  const raycaster = new THREE.Raycaster();
  raycaster.far = armaConfig.alcance;
  raycaster.layers.set(0);  // Solo detectar layer 0 (enemigos), ignorar layer 1 (sprites)

  const direction = new THREE.Vector3(0, 0, -1);
  direction.applyQuaternion(camera.getWorldQuaternion(new THREE.Quaternion()));
  raycaster.set(camera.getWorldPosition(new THREE.Vector3()), direction);

  const objetivos = [...enemigos, ...(jefe ? [jefe] : [])];
  const hits = raycaster.intersectObjects(objetivos, true)
    .filter(hit => !hit.object.userData.esTextoVida);

  if(hits.length > 0) {
    // Buscar el grupo enemigo en la jerarqu√≠a de forma robusta
    let obj = hits[0].object;
    let maxIteraciones = 10;

    while(obj && obj.parent && !obj.userData.esEnemigo && maxIteraciones > 0) {
      obj = obj.parent;
      maxIteraciones--;
    }

    // Verificar que encontramos un enemigo v√°lido con doble validaci√≥n
    if(obj && obj.userData && obj.userData.esEnemigo) {
      if(typeof obj.vida !== 'number') {
        console.warn('ENEMIGO SIN VIDA V√ÅLIDA:', obj, obj.vida);
        return;
      }

      obj.vida -= armaConfig.danio;
      playSound('hit');

      // SANGRE roja
      crearExplosion(hits[0].point, 0xaa0000, 15);

      // MOSTRAR DA√ëO FLOTANTE
      mostrarDanio(hits[0].point, armaConfig.danio);

      // ACTUALIZAR BARRA INMEDIATAMENTE
      actualizarBarraVida(obj);

      // Parpadeo rojo
      obj.traverse((child) => {
        if(child.material && child.material.color && !child.userData.esTextoVida) {
          const originalColor = child.material.color.clone();
          child.material.color.setHex(0xff0000);
          setTimeout(() => {
            if(child.material) child.material.color.copy(originalColor);
          }, 100);
        }
      });

      if(obj.vida <= 0) {
        playSound('death');
        crearExplosion(obj.position, 0xaa0000, 40); // Explosi√≥n de sangre
        scene.remove(obj);

        if(obj === jefe) {
          bajasTotal++;
          jefe = null;
          nivelCompletado();
        } else {
          enemigos = enemigos.filter(e => e !== obj);
          bajasTotal++;
        }
      }

      // ACTUALIZAR HUD DESPU√âS DE CADA DISPARO
      actualizarHUD();
    }
  }

  // L√≠nea de trazado (solo pistola)
  if(armaActual === 'pistola') {
    const lineGeometry = new THREE.BufferGeometry().setFromPoints([
      camera.getWorldPosition(new THREE.Vector3()),
      camera.getWorldPosition(new THREE.Vector3()).add(direction.clone().multiplyScalar(1000))
    ]);
    const line = new THREE.Line(
      lineGeometry,
      new THREE.LineBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.6 })
    );
    scene.add(line);
    setTimeout(() => scene.remove(line), 50);
  }
});

// ============ NIVEL COMPLETADO ============
function nivelCompletado() {
  if(enemigos.length === 0 && !jefe) {
    playSound('levelup');

    // CREAR PORTAL
    crearPortal();

    document.getElementById('lc-bajas').textContent = bajasTotal;
    document.getElementById('lc-vida').textContent = Math.round(vidaJugador);
    document.getElementById('level-complete').style.display = 'block';

    // No avanzar autom√°ticamente, esperar a que entre al portal
  }
}

// ============ GAME OVER ============
function gameOver() {
  document.getElementById('go-nivel').textContent = nivel;
  document.getElementById('go-bajas').textContent = bajasTotal;
  document.getElementById('game-over').style.display = 'block';
  gameStarted = false;
}

// ============ LOOP PRINCIPAL ============
let lastTime = Date.now();

function animate() {
  requestAnimationFrame(animate);

  if(gamePaused || !gameStarted || vidaJugador <= 0) {
    renderer.render(scene, camera);
    return;
  }

  const currentTime = Date.now();
  const deltaTime = (currentTime - lastTime) / 16.67;
  lastTime = currentTime;

  // Movimiento del jugador
  const moveSpeed = 0.12 * deltaTime;
  const forward = new THREE.Vector3(0, 0, -1);
  const right = new THREE.Vector3(1, 0, 0);

  forward.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);
  right.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationY);

  if(keys['w']) player.position.add(forward.multiplyScalar(moveSpeed));
  if(keys['s']) player.position.add(forward.multiplyScalar(-moveSpeed));
  if(keys['a']) player.position.add(right.multiplyScalar(-moveSpeed));
  if(keys['d']) player.position.add(right.multiplyScalar(moveSpeed));

  // Aplicar rotaci√≥n
  player.rotation.y = rotationY;
  camera.rotation.x = rotationX;

  // Sacudida de c√°mara
  if(cameraShake > 0) {
    camera.position.x += (Math.random() - 0.5) * cameraShake;
    camera.position.y += (Math.random() - 0.5) * cameraShake;
    cameraShake *= 0.9;

    if(cameraShake < 0.001) {
      cameraShake = 0;
      camera.position.x = 0;
      camera.position.y = 1.6;
    }
  }

  // Actualizar bombas
  actualizarBombas(deltaTime);

  // Animaci√≥n y detecci√≥n de portal
  if(portal && portal.parent) {
    // Rotaci√≥n
    portal.rotation.y += 0.01;

    // Part√≠culas flotantes
    portal.children.forEach((child, i) => {
      if(i > 1 && child.geometry?.type === 'SphereGeometry') {
        child.position.y += Math.sin(Date.now() * 0.001 + child.userData.offsetY) * 0.01;
      }
    });

    // Detectar entrada al portal
    const dist = player.position.distanceTo(portal.position);
    if(dist < 2.5) {
      // Jugador entr√≥ al portal
      scene.remove(portal);
      portal = null;

      document.getElementById('level-complete').style.display = 'none';
      nivel++;
      vidaJugador = Math.min(100, vidaJugador + 20);
      aplicarTema(nivel);
      crearEnemigos();
      actualizarHUD();
    }
  }

  // Animaci√≥n y detecci√≥n de items de vida
  itemsVida.forEach((item, index) => {
    if(!item.parent) return;

    // Rotaci√≥n continua
    item.rotation.y += 0.02 * deltaTime;

    // Flotaci√≥n suave
    item.position.y = 0.5 + Math.sin(Date.now() * 0.003) * 0.2;

    // Detectar recogida
    const dist = player.position.distanceTo(item.position);

    if(dist < 1.8) {
      // Recoger item
      vidaJugador = Math.min(100, vidaJugador + item.userData.curacion);

      // Efecto visual rosa
      crearExplosion(item.position, 0xff0066, 30);
      playSound('levelup'); // Sonido positivo

      // Remover item
      scene.remove(item);
      itemsVida.splice(index, 1);

      // Actualizar HUD
      actualizarHUD();
    }
  });

  // Movimiento de enemigos
  [...enemigos, jefe].forEach(e => {
    if(!e || !e.parent) return;

    // Mirar al jugador
    e.lookAt(player.position);

    // Moverse hacia el jugador
    const direction = new THREE.Vector3();
    direction.subVectors(player.position, e.position);
    direction.y = 0;
    direction.normalize();

    e.position.add(direction.multiplyScalar(e.velocidad * deltaTime));

    // Animaci√≥n de cola
    const cola = e.children.find(c => c.geometry?.type === 'CylinderGeometry' && c.position.z < 0);
    if(cola) {
      cola.rotation.x = Math.PI / 4 + Math.sin(Date.now() * 0.01) * 0.2;
    }

    // Colisi√≥n con jugador
    const dist = player.position.distanceTo(e.position);
    if(dist < 1.5) {
      vidaJugador -= e.danio * 0.016 * deltaTime;

      // Efecto de da√±o
      const overlay = document.getElementById('damage-overlay');
      overlay.classList.add('active');
      setTimeout(() => overlay.classList.remove('active'), 300);

      if(Math.random() < 0.1) playSound('damage');

      actualizarHUD();

      if(vidaJugador <= 0) {
        gameOver();
      }
    }
  });

  renderer.render(scene, camera);
}

// ============ RESPONSIVE ============
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>

</body>
</html>
